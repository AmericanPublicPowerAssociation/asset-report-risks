import pickle
from fuzzywuzzy.process import extract as extract_matches
from invisibleroads_macros.iterable import flatten_lists
from pymongo import MongoClient

from .settings import CVE_PATH


def get_nvd_database():
    mongo_client = MongoClient()
    vulnerability_database = mongo_client['vulnerability']
    return vulnerability_database['nvd']


def save_cve(cve):
    return pickle.dump(cve, open(CVE_PATH, 'wb'), protocol=-1)


def load_cve():
    return pickle.load(open(CVE_PATH, 'rb'))


def select_matches(target_texts, source_texts, minimum_score, maximum_count):
    matches = sorted(flatten_lists(extract_matches(
        _, source_texts, limit=maximum_count,
    ) for _ in target_texts), key=lambda _: -_[1])
    return [text for text, score in matches if minimum_score <= score]


def get_vendor_names(cve, component_type):
    return set(cve[component_type].keys())


def query_product_names(
        cve,
        component_type,
        vendor_names,
        product_names,
        minimum_score,
        maximum_count):
    all_product_names = set(flatten_lists(cve[
        component_type][_].keys() for _ in vendor_names))
    # component_type == 'h' and all_product_names.update(flatten_lists(
    #    cve['o'][_].keys() for _ in vendor_names))
    product_matches = sorted(flatten_lists(select_fuzzy_matches(
        _, all_product_names, limit=maximum_count,
    ) for _ in product_names), key=lambda _: -_[1])
    limit_score = define_limit_score(minimum_score)
    return [_[0] for _ in filter(limit_score, product_matches)]


def query_product_versions(
        cve,
        component_type,
        vendor_names,
        product_names,
        product_versions,
        minimum_score,
        maximum_count):
    all_product_versions = set()
    version_packs = set(flatten_lists(cve[
        component_type][vendor_name][product_name].keys()
        for product_name in product_names
        for vendor_name in vendor_names))
    """
    if component_type == 'h':
        more_vendor_names = 
    """
    component_type == 'h' and version_packs.update(flatten_lists(cve[
        'o'][vendor_name][product_name + '_firmware'].keys()
        for product_name in query_product_names(cve, 'o', vendor_names)
        for vendor_name in query_vendor_names(cve, 'o', vendor_names, minimum_score, maximum_count)))
    for version_pack in version_packs:
        all_product_versions.update(version_pack)
    if None in all_product_versions:
        all_product_versions.remove(None)
    if '-' in all_product_versions:
        all_product_versions.remove('-')
    if set(product_versions) == {''}:
        return sorted(all_product_versions)
    version_matches = sorted(flatten_lists(select_fuzzy_matches(
        _, all_product_versions, limit=maximum_count,
    ) for _ in product_versions), key=lambda _: -_[1])
    limit_score = define_limit_score(minimum_score)
    return [_[0] for _ in filter(limit_score, version_matches)]
